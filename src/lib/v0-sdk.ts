import { z } from "zod";
import { v0 } from 'v0-sdk'
// import AdmZip from 'adm-zip';
import { pushFilesAsCommit } from "../lib/git";

/*
export const generateCodeTool = createTool({
  id: 'generate-code',
  description: 'Generate Next.js code for a given task prompt. Returns enhanced prompt, system prompt, and generated code.',
  inputSchema: z.object({
    prompt: z.string().describe('User task prompt describing what code needs to be generated'),
    chatId: z.string().optional().describe('The ID of an existing v0 chat session to continue'),
  }),
  outputSchema: z.object({
    userEnhancedPrompt: z.string().describe('Enhanced user prompt with full technical context'),
    systemPrompt: z.string().describe('Production-grade system prompt for the code generator'),
    chatId: z.string().describe('The ID of the v0 chat session'),
    projectTitle: z.string().describe('The title of the generated project'),
    projectUrl: z.string().describe('The web URL of the project'),
    projectId: z.string().describe('The ID of the v0 project'),
    latestVersionId: z.string().optional().describe('The ID of the latest version'),
    demoUrl: z.string().optional().describe('The URL of the live demo'),
    files: z.array(z.object({
      name: z.string(),
      content: z.string(),
    })).optional().describe('The files generated by v0'),
  }),
  execute: async ({ context, mastra }) => {
    if (!context.prompt) {
      throw new Error('No prompt provided');
    }

    if (!mastra) {
      throw new Error('Failed to get mastra instance');
    }

    const agent = mastra.getAgent('coderAgent');

    if (!agent) {
      throw new Error('Failed to get coder agent');
    }

    try {
      const generationResponse = await agent.generate(
        `Analyze the following user request and generate two things:
 1. An enhanced user prompt with complete technical context.
 2. A production-grade system prompt tailored for this specific task.
 
 USER REQUEST: "${context.prompt}"
 
 Output MUST be a raw JSON object with keys "userEnhancedPrompt" and "systemPrompt".
 Do NOT use markdown code blocks. Do NOT include explanations.`,
        {
          instructions: `# ROLE
 You are a Technical Architect and Prompt Engineer specializing in Next.js.
 
 # OBJECTIVE
 Analyze the user's request and generate optimized prompts for a code generation AI.
 
 # CHAIN OF THOUGHT PROCESS (Perform these steps mentally)
 
 1. **Analyze Request**: Understand the core requirement, complexity, and implied needs.
 2. **Determine Stack**: Confirm Next.js App Router, TypeScript, Tailwind, shadcn/ui.
 3. **Consult Knowledge**: Recall best practices for these specific technologies (Server Components, Types, Accessibility).
 4. **Draft Enhanced User Prompt**: 
    - Expand the user's request with specific technical details.
    - Mention specific components and libraries.
    - Add requirements for error handling, loading states, and accessibility.
 5. **Draft System Prompt**:
    - Define the persona (Elite Next.js Developer).
    - Set strict rules for the specific task (e.g., if it's a form, emphasize validation; if it's a dashboard, emphasize layout).
    - Include the standard "Non-Negotiable" architecture principles (Server-First, Type Safety).
 6. **Format Output**: Construct the final JSON.
 
 # OUTPUT SPECIFICATION
 You must return ONLY a valid JSON object.
 Format:
 {
   "userEnhancedPrompt": "...",
   "systemPrompt": "..."
 }
 
 ## Content Guidelines
 
 ### userEnhancedPrompt
 - Should be a comprehensive paragraph.
 - Explicitly state the technology stack and version.
 - List specific features, components, and patterns to implement.
 - Include requirements for types, JSDoc, and best practices.
 
 ### systemPrompt
 - Define the Persona: Elite Next.js Developer.
 - Mandatory Stack: Next.js 14+ (App Router), TypeScript, Tailwind, shadcn/ui.
 - Architecture: Server-First, Strict Types, Performance, Accessibility.
 - Coding Standards: File structure, naming conventions, error handling.
 - Output Format: Complete, runnable code with no placeholders.
 - Tailor this prompt to the specific nature of the user's request (e.g., add specific rules for charts if requested).`,
          maxSteps: 5,
          modelSettings: {
            temperature: 0.3,
            topP: 0.9,
            topK: 40,
          }
        }
      );

      // Parse the JSON response
      let prompts;
      try {
        const cleanText = generationResponse.text.replace(/```json\n?|```/g, '').trim();
        prompts = JSON.parse(cleanText);
      } catch (e) {
        console.error("Failed to parse agent response as JSON:", generationResponse.text);
        throw new Error("Agent failed to generate valid JSON prompts.");
      }

      const { userEnhancedPrompt, systemPrompt } = prompts;

      if (!userEnhancedPrompt || !systemPrompt) {
        throw new Error("Generated JSON missing required fields.");
      }

      const chat = await generateCode(userEnhancedPrompt, context.chatId);

      const chatData = chat as any;
      const chatId = chatData.id;
      const projectTitle = chatData.title || 'Untitled Project';
      const projectUrl = chatData.webUrl || `https://v0.app/chat/${chatId}`;
      const projectId = chatData.projectId || '';
      const latestVersionId = chatData.latestVersion?.id;
      const demoUrl = chatData.latestVersion?.demoUrl;
      const files = chatData.latestVersion?.files;

      return {
        userEnhancedPrompt,
        systemPrompt,
        chatId,
        projectTitle,
        projectUrl,
        projectId,
        latestVersionId,
        demoUrl,
        files
      };

    } catch (err) {
      console.error('Error occurred while generating code:', err);
      throw new Error(`Failed to generate code: ${err instanceof Error ? err.message : 'Unknown error'}`);
    }
  },
});
*/

export const generateCode = async (userPrompt: string, chatId?: string) => {
  try {
    let chat;
    if (chatId) {
      chat = await v0.chats.sendMessage({
        chatId: chatId,
        message: userPrompt,
      });
    } else {
      chat = await v0.chats.create({
        message: userPrompt,
      });
    }

    return chat;
  } catch (error) {
    console.error('Error calling v0 SDK:', error);
    throw new Error(`v0 SDK error: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/*
export const checkExistingProjectTool = createTool({
  id: 'check-existing-project',
  description: 'Check if a project exists for a given chat ID.',
  inputSchema: z.object({
    check: z.boolean().optional().describe('Whether to check for an existing project (always true)')
  }),
  outputSchema: z.object({
    project: z.any().describe('Projects found'),
  }),
  execute: async ({ context }) => {
    try {
      const project = await v0.projects.find();
      return { project };
    } catch (error) {
      console.error('Error checking existing project:', error);
      return { project: null };
    }
  },
});

export const deleteProjectTool = createTool({
  id: 'delete-project',
  description: 'Delete a project for a given chat ID.',
  inputSchema: z.object({ projectId: z.string().describe('The project ID') }),
  outputSchema: z.object({
    id: z.string().describe('The project ID'),
    object: z.string().describe("Entity type"),
    deleted: z.boolean().describe("Whether the project was deleted"),
  }),
  execute: async ({ context }) => {
    try {
      const deletedProject = await v0.projects.delete({
        projectId: context.projectId,
      });

      if (!deletedProject) {
        throw new Error('Project not found');
      }

      return deletedProject
    } catch (error) {
      console.error('Error deleting project:', error);
      return { id: context.projectId, object: "project", deleted: false }
    }
  },
});
*/

// export const downloadLatestVersionTool = async (chatId: string, latestVersionId: string) => {
//   try {
//     const zipData = await v0.chats.downloadVersion({
//       chatId,
//       versionId: latestVersionId,
//     })

//     // Convert ArrayBuffer to Buffer
//     const buffer = Buffer.from(zipData as ArrayBuffer);

//     // Extract files in memory
//     const zip = new AdmZip(buffer);
//     const zipEntries = zip.getEntries();

//     const files = zipEntries
//       .filter(entry => !entry.isDirectory)
//       .map(entry => ({
//         path: entry.entryName,
//         content: entry.getData().toString('utf8'),
//       }));

//     return files;
//   } catch (error) {
//     console.error('Error calling v0 SDK:', error);
//     throw new Error(`v0 SDK error: ${error instanceof Error ? error.message : 'Unknown error'}`);
//   }
// };

/*
export const pushFilesAsCommitTool = createTool({
  id: "push-files-as-commit-tool",
  description: "Push files as a commit to a GitHub repository. Automatically creates the repository if it doesn't exist.",
  inputSchema: z.object({
    chatId: z.string().describe('The v0 chat id'),
    latestVersionId: z.string().describe('The latest version id from v0'),
    repository: z.string().describe('The repository name (without owner)'),
    newBranch: z.string().optional().describe('Optional: Create and push to a new branch'),
    commitMessage: z.string().describe('The commit message'),
    repoDescription: z.string().optional().describe('Optional: Description for the repository if creating new'),
    demoUrl: z.string().optional().describe('Optional: Demo URL to append to repository description'),
  }),
  outputSchema: z.object({
    commitSHA: z.string().describe('The SHA of the created commit'),
    repoUrl: z.string().describe('The full GitHub repository URL'),
    branchUrl: z.string().describe('The direct link to the branch on GitHub'),
  }),
  execute: async ({ context }) => {
    try {
      const files = await downloadLatestVersionTool(context.chatId, context.latestVersionId);

      if (files.length === 0) {
        throw new Error('No files found in the latest version');
      }

      // Append demo URL to repository description if provided
      // GitHub doesn't allow control characters (newlines) in descriptions
      let finalDescription = context.repoDescription || '';
      if (context.demoUrl) {
        const separator = finalDescription ? ' | ' : '';
        finalDescription = finalDescription + `${separator}ðŸ”— Live Demo: ${context.demoUrl}`;
      }

      const pushFilesResp = await pushFilesAsCommit({
        owner: process.env.GITHUB_OWNER!,
        repo: context.repository,
        baseBranch: 'main',
        newBranch: context.newBranch || '',
        files: files,
        commitMessage: context.commitMessage,
        token: process.env.GITHUB_TOKEN!,
        repoDescription: finalDescription,
      });

      return pushFilesResp;

    } catch (error) {
      console.error('Error pushing files to GitHub:', error);
      throw new Error(`Failed to push files: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  },
});
*/